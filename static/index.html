<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stentor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #f3f4f6;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
        }

        .card {
            background: #fff;
            border-radius: 16px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.08);
            padding: 2.5rem 2rem;
            max-width: 400px;
            width: 100%;
            text-align: center;
        }

        h1 {
            display: inline-block;
            font-size: 1.4rem;
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #2563eb;
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            border-radius: 10px;
            padding: 0.6rem 1.8rem;
            margin-bottom: 2rem;
        }

        footer {
            margin-top: 1.5rem;
            text-align: center;
            font-size: 0.75rem;
            color: #9ca3af;
            line-height: 1.6;
        }

        footer a {
            color: #6b7280;
            text-decoration: none;
            font-weight: 600;
        }

        footer a:hover {
            color: #2563eb;
        }

        .tooltip-wrap {
            position: relative;
            display: inline-block;
        }

        .tooltip-wrap .tooltip {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%) translateY(4px);
            background: #1f2937;
            color: #f3f4f6;
            font-size: 0.7rem;
            font-weight: 400;
            line-height: 1.5;
            padding: 0.6rem 0.8rem;
            border-radius: 8px;
            width: 240px;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
        }

        .tooltip-wrap .tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: #1f2937;
        }

        .tooltip-wrap:hover .tooltip {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            font-size: 1.1rem;
            font-weight: 500;
            min-height: 1.75rem;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .status-dot.ready { background: #9ca3af; }
        .status-dot.live { background: #22c55e; animation: pulse 1s infinite; }
        .status-dot.busy { background: #ef4444; }
        .status-dot.error { background: #ef4444; }
        .status-dot.disconnected { background: #f59e0b; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .btn-talk {
            width: 100%;
            padding: 1.25rem 1rem;
            border: none;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            transition: background 0.15s, transform 0.1s;
            background: #2563eb;
            color: #fff;
        }

        .btn-talk:active:not(:disabled),
        .btn-talk.active {
            background: #22c55e;
            transform: scale(0.97);
        }

        .btn-talk:disabled {
            background: #d1d5db;
            color: #9ca3af;
            cursor: not-allowed;
        }

        .btn-hint {
            display: block;
            margin-top: 0.35rem;
            font-size: 0.8rem;
            font-weight: 400;
            opacity: 0.8;
        }

        .timer {
            margin-top: 1.5rem;
            font-size: 2rem;
            font-weight: 700;
            color: #111827;
            min-height: 3rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }

        .timer-label {
            font-size: 0.85rem;
            font-weight: 400;
            color: #6b7280;
        }

        .timer.warning {
            color: #ef4444;
        }

        .error-msg {
            margin-top: 1rem;
            padding: 0.75rem 1rem;
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 8px;
            color: #991b1b;
            font-size: 0.9rem;
            display: none;
        }

        .mic-controls {
            margin-bottom: 1rem;
        }

        .mic-selector-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .mic-select {
            flex: 1;
            min-width: 0;
            padding: 0.4rem 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 0.85rem;
            color: #374151;
            background: #fff;
            outline: none;
            transition: border-color 0.15s, box-shadow 0.15s;
        }

        .mic-select:focus {
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
        }

        .mic-select:disabled {
            background: #f3f4f6;
            color: #9ca3af;
            cursor: not-allowed;
        }

        .btn-mute {
            width: 36px;
            height: 36px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background: #fff;
            cursor: pointer;
            color: #6b7280;
            transition: background 0.15s, border-color 0.15s, color 0.15s;
        }

        .btn-mute:hover {
            background: #f3f4f6;
        }

        .btn-mute.muted {
            background: #fef2f2;
            border-color: #fecaca;
            color: #ef4444;
        }

        .btn-mute.muted:hover {
            background: #fee2e2;
        }
    </style>
</head>
<body>
    <div class="card">
        <h1 id="app-title">Stentor</h1>

        <div class="status">
            <span class="status-dot ready" id="status-dot"></span>
            <span id="status-text">A ligar...</span>
        </div>

        <div class="mic-controls">
            <div class="mic-selector-row">
                <select id="mic-select" class="mic-select">
                    <option value="">A carregar...</option>
                </select>
                <button id="btn-mute" class="btn-mute" title="Silenciar microfone (M)">
                    <svg id="mute-icon-on" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                        <line x1="1" y1="1" x2="23" y2="23"/>
                        <path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"/>
                        <path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2c0 .67-.1 1.32-.27 1.93"/>
                        <line x1="12" y1="19" x2="12" y2="23"/>
                        <line x1="8" y1="23" x2="16" y2="23"/>
                    </svg>
                    <svg id="mute-icon-off" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                        <line x1="12" y1="19" x2="12" y2="23"/>
                        <line x1="8" y1="23" x2="16" y2="23"/>
                    </svg>
                </button>
            </div>
        </div>

        <button class="btn-talk" id="btn-talk" disabled>
            Manter premido para falar
            <span class="btn-hint">ou manter Espaço premido</span>
        </button>

        <div class="timer" id="timer"></div>

        <div class="error-msg" id="error-msg"></div>
    </div>

    <footer>
        <span class="tooltip-wrap">
            <a href="https://github.com/mglraimundo/stentor" target="_blank">Stentor</a>
            <span class="tooltip">In Greek mythology, Stentor was a herald during the Trojan War whose voice was as powerful as fifty men.</span>
        </span><br>
        Desenvolvido por Miguel Raimundo
    </footer>

    <script>
    (function () {
        // --- Config ---
        let config = {
            app_name: "Stentor",
            favicon_letter: "S",
            favicon_bg_color: "#2563EB",
            favicon_text_color: "#FFFFFF",
            broadcast_timeout_seconds: 20,
        };

        // --- DOM ---
        const appTitle = document.getElementById("app-title");
        const statusDot = document.getElementById("status-dot");
        const statusText = document.getElementById("status-text");
        const btnTalk = document.getElementById("btn-talk");
        const timerEl = document.getElementById("timer");
        const errorMsg = document.getElementById("error-msg");
        const micSelect = document.getElementById("mic-select");
        const btnMute = document.getElementById("btn-mute");
        const muteIconOn = document.getElementById("mute-icon-on");
        const muteIconOff = document.getElementById("mute-icon-off");

        // --- State ---
        let ws = null;
        let myClientId = null;
        let mediaStream = null;
        let mediaRecorder = null;
        let isBroadcasting = false;
        let isRequesting = false;
        let countdownInterval = null;
        let secondsRemaining = 0;
        let lastReleaseTime = 0;
        let spaceHeld = false;
        let mouseHeld = false;
        let stopBroadcastTimer = null;
        let selectedDeviceId = null;
        let isMuted = false;

        const DEBOUNCE_MS = 500;
        const RECONNECT_MS = 3000;

        // --- Favicon ---
        function setFavicon(letter, bgColor, textColor) {
            const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
                <circle cx="32" cy="32" r="32" fill="${bgColor}"/>
                <text x="32" y="32" dy=".35em" text-anchor="middle"
                      font-family="sans-serif" font-weight="bold" font-size="36"
                      fill="${textColor}">${letter}</text>
            </svg>`;
            const blob = new Blob([svg], { type: "image/svg+xml" });
            const url = URL.createObjectURL(blob);
            let link = document.querySelector("link[rel='icon']");
            if (!link) {
                link = document.createElement("link");
                link.rel = "icon";
                document.head.appendChild(link);
            }
            link.href = url;
        }

        // --- Config fetch ---
        async function loadConfig() {
            try {
                const resp = await fetch("/config");
                config = await resp.json();
            } catch (e) {
                console.warn("Failed to load /config, using defaults");
            }
            document.title = config.app_name;
            appTitle.textContent = config.app_name;
            setFavicon(config.favicon_letter, config.favicon_bg_color, config.favicon_text_color);
        }

        // --- UI helpers ---
        function setStatus(state, text) {
            statusDot.className = "status-dot " + state;
            statusText.textContent = text;
        }

        function showError(msg) {
            errorMsg.textContent = msg;
            errorMsg.style.display = "block";
        }

        function hideError() {
            errorMsg.style.display = "none";
        }

        function updateTimer() {
            if (!isBroadcasting) {
                timerEl.innerHTML = "";
                timerEl.classList.remove("warning");
                return;
            }
            const warn = secondsRemaining <= 5;
            timerEl.classList.toggle("warning", warn);
            timerEl.innerHTML =
                `<span class="timer-label">${warn ? "A terminar..." : "Tempo restante"}</span>` +
                `<span>${secondsRemaining}s</span>`;
        }

        function startCountdown(seconds) {
            stopCountdown();
            secondsRemaining = seconds;
            updateTimer();
            countdownInterval = setInterval(function () {
                secondsRemaining = Math.max(0, secondsRemaining - 1);
                updateTimer();
            }, 1000);
        }

        function stopCountdown() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            timerEl.innerHTML = "";
            timerEl.classList.remove("warning");
        }

        // --- Microphone ---
        async function ensureMicrophone(deviceId) {
            if (mediaStream && !deviceId) return true;
            if (deviceId && mediaStream) {
                mediaStream.getTracks().forEach(function (t) { t.stop(); });
                mediaStream = null;
            }
            try {
                var audioConstraints = {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    channelCount: 1,
                    sampleRate: 48000,
                };
                if (deviceId) {
                    audioConstraints.deviceId = { exact: deviceId };
                }
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: audioConstraints
                });
                mediaStream.getAudioTracks().forEach(function (t) {
                    t.enabled = !isMuted;
                });
                return true;
            } catch (e) {
                showError("Permissão de microfone negada. Verifique as definições do navegador.");
                btnTalk.disabled = true;
                return false;
            }
        }

        async function populateMicList() {
            try {
                var devices = await navigator.mediaDevices.enumerateDevices();
                var mics = devices.filter(function (d) { return d.kind === "audioinput"; });

                if (mics.length === 0) {
                    micSelect.innerHTML = '<option value="">Nenhum microfone encontrado</option>';
                    micSelect.disabled = true;
                    return;
                }

                micSelect.disabled = false;
                micSelect.innerHTML = "";
                mics.forEach(function (mic, i) {
                    var opt = document.createElement("option");
                    opt.value = mic.deviceId;
                    opt.textContent = mic.label || ("Microfone " + (i + 1));
                    micSelect.appendChild(opt);
                });

                var saved = localStorage.getItem("stentor_mic_device_id");
                if (saved && mics.some(function (m) { return m.deviceId === saved; })) {
                    micSelect.value = saved;
                    selectedDeviceId = saved;
                } else {
                    selectedDeviceId = mics[0].deviceId;
                    micSelect.value = selectedDeviceId;
                }
            } catch (e) {
                console.warn("Failed to enumerate devices", e);
            }
        }

        async function switchMicrophone(deviceId) {
            selectedDeviceId = deviceId;
            localStorage.setItem("stentor_mic_device_id", deviceId);

            if (isBroadcasting) {
                stopRecording();
                var ok = await ensureMicrophone(deviceId);
                if (ok) startRecording();
            } else {
                await ensureMicrophone(deviceId);
            }
        }

        function toggleMute() {
            isMuted = !isMuted;
            if (mediaStream) {
                mediaStream.getAudioTracks().forEach(function (t) {
                    t.enabled = !isMuted;
                });
            }
            btnMute.classList.toggle("muted", isMuted);
            muteIconOn.style.display = isMuted ? "block" : "none";
            muteIconOff.style.display = isMuted ? "none" : "block";
            updateTalkButtonState();
        }

        function updateTalkButtonState() {
            if (isMuted) {
                btnTalk.innerHTML = 'Microfone silenciado<span class="btn-hint">clique no botão de silenciar para reativar</span>';
                btnTalk.disabled = true;
            } else {
                btnTalk.innerHTML = 'Manter premido para falar<span class="btn-hint">ou manter Espaço premido</span>';
                btnTalk.disabled = !mediaStream;
            }
        }

        function startRecording() {
            if (!mediaStream || !ws) return;
            try {
                mediaRecorder = new MediaRecorder(mediaStream, {
                    mimeType: "audio/webm;codecs=opus",
                    audioBitsPerSecond: 64000,
                });
            } catch (e) {
                // Fallback if specific mime not supported
                mediaRecorder = new MediaRecorder(mediaStream);
            }
            mediaRecorder.ondataavailable = function (event) {
                if (event.data.size > 0 && ws && ws.readyState === WebSocket.OPEN && isBroadcasting) {
                    ws.send(event.data);
                }
            };
            mediaRecorder.start(250);
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                try { mediaRecorder.stop(); } catch (e) {}
            }
            mediaRecorder = null;
        }

        // --- Broadcast ---
        function startBroadcast() {
            if (isMuted) return;
            if (isBroadcasting || isRequesting) return;
            if (Date.now() - lastReleaseTime < DEBOUNCE_MS) return;
            if (!ws || ws.readyState !== WebSocket.OPEN) return;

            isRequesting = true;
            ws.send(JSON.stringify({ type: "request_broadcast" }));
        }

        function stopBroadcast() {
            lastReleaseTime = Date.now();
            isRequesting = false;

            if (!isBroadcasting) return;
            btnTalk.classList.remove("active");
            stopCountdown();
            setStatus("ready", "Pronto");

            // Keep isBroadcasting = true for 1s tail so chunks keep being sent
            stopBroadcastTimer = setTimeout(function () {
                stopBroadcastTimer = null;
                isBroadcasting = false;
                stopRecording();
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: "stop_broadcast" }));
                }
            }, 1000);
        }

        function forceStopBroadcast() {
            if (stopBroadcastTimer !== null) {
                clearTimeout(stopBroadcastTimer);
                stopBroadcastTimer = null;
            }
            isBroadcasting = false;
            isRequesting = false;
            stopRecording();
        }

        function onBroadcastGranted() {
            isRequesting = false;
            isBroadcasting = true;
            btnTalk.classList.add("active");
            setStatus("live", "Em direto");
            hideError();
            startCountdown(config.broadcast_timeout_seconds);
            startRecording();
        }

        function onBroadcastDenied() {
            isRequesting = false;
            setStatus("busy", "Altifalante ocupado — aguarde");
            setTimeout(function () {
                if (!isBroadcasting) {
                    setStatus("ready", "Pronto");
                }
            }, 2000);
        }

        function onBroadcastEnded() {
            forceStopBroadcast();
            btnTalk.classList.remove("active");
            stopCountdown();
            setStatus("ready", "Transmissão terminada");
            setTimeout(function () {
                if (!isBroadcasting) {
                    setStatus("ready", "Pronto");
                }
            }, 2000);
        }

        function onStateUpdate(data) {
            if (isBroadcasting) {
                // We are the active broadcaster, update timer from server
                if (data.seconds_remaining !== null) {
                    secondsRemaining = data.seconds_remaining;
                    updateTimer();
                }
                return;
            }

            if (data.is_active) {
                setStatus("busy", "Altifalante ocupado — aguarde");
                btnTalk.disabled = true;
            } else {
                setStatus("ready", "Pronto");
                btnTalk.disabled = isMuted || !mediaStream;
            }
        }

        // --- WebSocket ---
        let reconnectTimeout = null;

        function connect() {
            const proto = location.protocol === "https:" ? "wss:" : "ws:";
            ws = new WebSocket(proto + "//" + location.host + "/ws");

            ws.onopen = function () {
                hideError();
                setStatus("ready", "Pronto");
                btnTalk.disabled = isMuted || !mediaStream;
            };

            ws.onmessage = function (event) {
                if (typeof event.data !== "string") return;
                const data = JSON.parse(event.data);

                switch (data.type) {
                    case "welcome":
                        myClientId = data.client_id;
                        break;
                    case "broadcast_granted":
                        if (data.client_id === myClientId) {
                            onBroadcastGranted();
                        }
                        break;
                    case "broadcast_denied":
                        onBroadcastDenied();
                        break;
                    case "broadcast_ended":
                        onBroadcastEnded();
                        break;
                    case "state_update":
                        onStateUpdate(data);
                        break;
                }
            };

            ws.onclose = function () {
                if (isBroadcasting || stopBroadcastTimer !== null) forceStopBroadcast();
                setStatus("disconnected", "Desligado — a tentar reconectar...");
                btnTalk.disabled = true;
                scheduleReconnect();
            };

            ws.onerror = function () {
                // onclose will fire after this
            };
        }

        function scheduleReconnect() {
            if (reconnectTimeout) return;
            reconnectTimeout = setTimeout(function () {
                reconnectTimeout = null;
                connect();
            }, RECONNECT_MS);
        }

        // --- Input handlers ---
        function isInputFocused() {
            const tag = document.activeElement && document.activeElement.tagName;
            return tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT";
        }

        // Mouse / touch
        btnTalk.addEventListener("mousedown", function (e) {
            e.preventDefault();
            mouseHeld = true;
            startBroadcast();
        });

        btnTalk.addEventListener("touchstart", function (e) {
            e.preventDefault();
            mouseHeld = true;
            startBroadcast();
        }, { passive: false });

        function onPointerRelease() {
            if (mouseHeld) {
                mouseHeld = false;
                stopBroadcast();
            }
        }

        document.addEventListener("mouseup", onPointerRelease);
        document.addEventListener("touchend", onPointerRelease);
        btnTalk.addEventListener("mouseleave", function () {
            if (mouseHeld) {
                mouseHeld = false;
                stopBroadcast();
            }
        });

        // Keyboard (Space + M)
        document.addEventListener("keydown", function (e) {
            if (isInputFocused()) return;
            if (e.code === "Space" && !e.repeat) {
                e.preventDefault();
                if (!spaceHeld) {
                    spaceHeld = true;
                    startBroadcast();
                }
            } else if (e.code === "KeyM" && !e.repeat) {
                toggleMute();
            }
        });

        document.addEventListener("keyup", function (e) {
            if (e.code !== "Space" || isInputFocused()) return;
            e.preventDefault();
            if (spaceHeld) {
                spaceHeld = false;
                stopBroadcast();
            }
        });

        // Mic select / mute / device change
        micSelect.addEventListener("change", function () {
            switchMicrophone(micSelect.value);
        });

        btnMute.addEventListener("click", function () {
            toggleMute();
            btnMute.blur();
        });

        navigator.mediaDevices.addEventListener("devicechange", async function () {
            var previousId = selectedDeviceId;
            await populateMicList();
            if (previousId && previousId !== selectedDeviceId) {
                var selectedLabel = micSelect.options[micSelect.selectedIndex]
                    ? micSelect.options[micSelect.selectedIndex].textContent
                    : "predefinido";
                showError("Microfone desligado. A usar: " + selectedLabel);
                setTimeout(hideError, 4000);
                await switchMicrophone(selectedDeviceId);
            }
        });

        // --- Init ---
        async function init() {
            await loadConfig();
            var saved = localStorage.getItem("stentor_mic_device_id");
            await ensureMicrophone(saved || undefined);
            await populateMicList();
            if (selectedDeviceId && selectedDeviceId !== (mediaStream && mediaStream.getAudioTracks()[0] && mediaStream.getAudioTracks()[0].getSettings().deviceId)) {
                await ensureMicrophone(selectedDeviceId);
            }
            updateTalkButtonState();
            connect();
        }

        init();
    })();
    </script>
</body>
</html>
